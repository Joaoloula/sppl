Probabilistic Programming with Sum-Product Networks
===================================================

The Kernel Language
-------------------

Domain Variables

  n ‚àà Naturals
  r ‚àà Reals
  w ‚àà [0,1]
  s ‚àà Strings
  x ‚àà Var

Transform Data Type

  i ‚àà InfiniteSet
    = Interval(r‚ÇÅ, r‚ÇÇ)                      // [r‚ÇÅ, r‚ÇÇ]
    | Interval.open(r‚ÇÅ, r‚ÇÇ)                 // (r‚ÇÅ, r‚ÇÇ)
    | Interval.Lopen(r‚ÇÅ, r‚ÇÇ)                // (r‚ÇÅ, r‚ÇÇ]
    | Interval.Ropen(r‚ÇÅ, r‚ÇÇ)                // [r‚ÇÅ, r‚ÇÇ)

  f ‚àà FiniteSet
    = EmptySet                              // ‚àÖ
    | FiniteSetReal(r‚ÇÅ, ‚Ä¶, r‚Çò)              // {r‚ÇÅ, ‚Ä¶, r‚Çò}
    | FiniteSetNominal(s‚ÇÅ, ‚Ä¶, s‚Çò)           // {s‚ÇÅ, ‚Ä¶, s‚Çò}

  v ‚àà Set
    = i
    | f
    | Union([v‚ÇÅ, ‚Ä¶, v‚Çò])                    // v‚ÇÅ ‚à™ ‚Ä¶ ‚à™ v‚Çò
    | Complement f                          // (by cases)

  t ‚àà Transform
    = Identity(x)                           // x               one-to-one
    | Reciprocal(t)                         // 1 / t(x)        one-to-one
    | Radical(t, n)                         // ‚Åø‚àöt(x)          one-to-one
    | Exponent(t, r)                        // r·µó‚ÅΩÀ£‚Åæ           one-to-one
    | Logarithm(t, r)                       // log·µ£(t(x))      one-to-one
    | Abs(t)                                // |t(x)|          many-to-one
    | Polynomial(t, [r‚ÇÄ, ‚Ä¶, r‚Çò])            // ‚àër·µ¢t‚Å±(x)        many-to-one
    | Piecewise([t‚ÇÅ, ‚Ä¶, t‚Çò], [e‚ÇÅ, ‚Ä¶, e‚Çò])   // ‚àëI[e·µ¢(x)]t·µ¢(x)  many-to-one

  e ‚àà Event <: Transforms
    = EventBasic(t, v)                      // {t(x) ‚àà v} = {y|t(y) ‚àà v}
    | EventOr([e‚ÇÅ, ‚Ä¶, e‚Çò])                  // e‚ÇÅ ‚à® ‚Ä¶ ‚à® e‚Çò
    | EventAnd([e‚ÇÅ, ‚Ä¶, e‚Çò])                 // e‚ÇÅ ‚àß ‚Ä¶ ‚àß e‚Çò
    | EventNot(e)                           // ~e

  invert              :: Transform ‚Üí Set ‚Üí Set
  solve               :: Event ‚Üí Set
  simplify            :: Event ‚Üí Event

SPN Type

  F ‚àà ‚Ñú ‚Üí [0,1]  (a CDF, i.e., F(x) = Œº((-‚àû, x]), and cadlag)

  d ‚àà Distribution
    = Nominal {s‚ÇÅ:p‚ÇÅ, ‚Ä¶, s‚Çò:p‚Çò}           // Œº({s·µ¢}) = p·µ¢
    | RealAtomic i F                      // Œº(i) := F(i) - F(i-1)
    | RealContinuous i F                  // Œº((-‚àû, x]) = F(x)

  s ‚àà SPN
    = (‚Ñì x d)                   [Leaf]
    | (‚äó s‚ÇÅ ‚Ä¶ s‚Çò)               [Product]
    | (‚äï (w‚ÇÅ s‚ÇÅ) ‚Ä¶ (w‚Çô s‚Çò))     [Sum]

The denotation of an SPN is a probability measure.
The scope function returns the set of distinct symbols in s:

  scope :: SPN ‚Üí {Vars}
  scope(‚Ñì x d) = {x}
  scope(‚äó s‚ÇÅ ‚Ä¶ s‚Çò) = ‚à™·µ¢ scope(s·µ¢)
  scope((‚äï (w‚ÇÅ s‚ÇÅ) ‚Ä¶ (w‚Çô s‚Çò))) = ‚à™·µ¢ scope(s·µ¢)

Let n = |scope(s)|.

  ùêè‚ü¶.‚üß :: SPN ‚Üí œÉ[(R ‚äé S)‚Åø] ‚Üí [0, 1]

  œÉ(R ‚äé S) := B(R ‚äé S)
  The Borel sigma algebra on the disjoint union topological space,
    where R is given the usual topology,
    and S is given the discrete topology.

  Semantic functions on SPN

  [Probability]         ùêè‚ü¶.‚üß :: SPN ‚Üí Event ‚Üí [0,1]
  [Condition]           ùêÇ‚ü¶.‚üß :: SPN ‚Üí Event ‚Üí SPN
  [Mutual Information]  ùêå‚ü¶.‚üß :: SPN ‚Üí Event ‚Üí Event ‚Üí Reals

- Give a denotational semantics of the kernel language
- Give a small-step operational semantics for the modeling language.

The Modeling Language
---------------------

Also known as the "syntactic sugar"

y ‚àà ArrVar
z ‚àà Vars = x | y[n]

  t ‚àà Transformations
    = x                         [Identity]
    | 1/t                       [Reciprocal]
    | ‚Åø‚àöt                       [Radical]
    | r·µó                        [Exp]
    | log(t, r)                 [Log]
    | abs(t)                    [Abs]
    | r‚ÇÄ + r‚ÇÅt + ‚Ä¶ + r‚Çòt·µê       [Polynomial]
    | œï‚ÇÅt‚ÇÅ + œï‚ÇÇt‚ÇÇ + ... + œï‚Çôt‚Çô  [Piecewise]

  f ‚àà FiniteOutcomes :=
    | {r‚ÇÅ, ‚Ä¶, r‚Çò}               [RealFinite]
    | {s‚ÇÅ, ‚Ä¶, s‚Çò}               [NominalFinite]

  c ‚àà Comparison = < | <=
  œï ‚àà Predicate :=
    | t c r                 [Less]
    | r c t                 [Greater]
    | t << f                [Containment]
    | œï‚ÇÅ & œï‚ÇÇ               [Conjunction]
    | œï‚ÇÅ | œï‚ÇÇ               [Disjunction]
    | ~œï                    [Negation]

  d ‚àà Dist
    = {s‚ÇÅ:p‚ÇÅ, ‚Ä¶, s‚Çò:p‚Çò}           [NominalDist]
    | Normal Œº ŒΩ | ‚Ä¶                [ContinuousDist]
    | Poisson Œª | ‚Ä¶                 [DiscreteDist]
    | w‚ÇÅ*d‚ÇÅ + ‚Ä¶ w‚Çô*d‚Çô               [MixtureDist]

  c ‚àà Program
    = y ‚Üê array(n)                                  [DeclareArr]
    | z ~ d                                         [Sample]
    | z ‚Üê t                                         [Transform]
    | c‚ÇÅ ; c‚ÇÇ                                       [Sequence]
    | if œï‚ÇÅ then c‚ÇÅ elif œï‚ÇÇ then c‚ÇÇ ‚Ä¶ else c‚Çô       [Condition]
    | repeat n n' Œªi.c                              [Repeat]

Small Step Semantics

  The semantics of a program c ‚àà Program is a
  sum-product network s ‚àà SPN.

  We will describe the mapping from the syntactic domain
  to the semantic domain using SOS.

  More specifically, the program state is a pair (s, œÉ) where
    œÉ ‚àà Vars ‚Üí Transforms
    s ‚àà SPN

  For any predicate œï ‚àà Predicate and environment œÉ, define
    œï[œÉ] = case œï of
      t in v    | var(t) ‚àà œÉ -> [œÉ[var(t)]] in v
                | otherwise -> œï
      œï‚ÇÅ and œï‚ÇÇ -> (œï‚ÇÅ[œÉ] and œï‚ÇÇ[œÉ])
      œï‚ÇÅ or œï‚ÇÇ -> (œï‚ÇÅ[œÉ] or œï‚ÇÇ[œÉ])
      ~œï -> ~œï[œÉ]


Big-Step Semantics for Distributions

[PrimitiveDist]       --------------------
                      Normal Œº ŒΩ ‚•• (RealContinuous (-‚àû, ‚àû) F‚Çô)

                      --------------------
                      Poisson Œº ‚•• (RealDiscrete [0, ‚àû) F‚Çö)

                      --------------------
                      {s‚ÇÅ:p‚ÇÅ, ‚Ä¶, s‚Çò:p‚Çò} ‚•• Nominal {s‚ÇÅ:p‚ÇÅ, ‚Ä¶, s‚Çò:p‚Çò}

                d·µ¢ ‚•• s·µ¢ (i=1, ‚Ä¶, n)
[MixtureDist]  ----------------------------------  (where ‚àë·µ¢w·µ¢ = 1)
                (w‚ÇÅ*d‚ÇÅ + ‚Ä¶ + w‚Çô*d‚Çô) ‚•• (‚äï (w·µ¢ s·µ¢))

Big-Step Semantics for Transformations

  ‚Ä¶

Small-Step Semantics for Commands

[Sample]  ----------------------------------
          ‚ü®(s, œÉ), x ~ d‚ü© ‚Üí (‚äó s (‚Ñì x d))

[Transform]  -----------------------------
             ‚ü®(s, œÉ), z ‚Üê t‚ü© ‚Üí (s, [z\t]œÉ)

             ‚ü®(s, œÉ), c‚ÇÅ ‚Üí (s‚ÇÅ, œÉ‚ÇÅ)  ‚ü®(s‚ÇÅ, œÉ‚ÇÅ), c‚ÇÇ ‚Üí (s‚ÇÇ, œÉ‚ÇÇ)
[Sequence]   ------------------------------------------------
                      ‚ü®(s, œÉ), c‚ÇÅ;c‚ÇÇ‚ü© ‚Üí (s‚ÇÇ, œÉ‚ÇÇ)

          ‚ü®(s|œï[œÉ], œÉ), c‚ÇÅ‚ü© ‚Üí (s‚ÇÅ, œÉ‚ÇÅ) ‚ü®(s|~œï[œÉ], œÉ), c‚ÇÇ‚ü© ‚Üí (s‚ÇÇ, œÉ‚ÇÇ)
[IfElse]  -----------------------------------------------------------
          ‚ü®(s, œÉ), if œï then c‚ÇÅ else c‚ÇÇ‚ü© ‚Üí ‚äï (ùêè‚ü¶s‚üß(œï[œÉ])) (s‚ÇÅ, œÉ‚ÇÅ)
                                             (1-ùêè‚ü¶s‚üß(~œï[œÉ])) (s‚ÇÇ, œÉ‚ÇÇ)

[Repeat-False]
      --------------------------------  (where n' <= n)
      ‚ü®(s, œÉ), repeat n n' Œªx.c‚ü© ‚Üí (s, œÉ)

[Repeat-True-v1]

    ------------------------------------------------------------  (where n < n')
    ‚ü®(s, œÉ), repeat n Œªx.c‚ü© ‚Üí ‚ü®(s, œÉ), ( (Œªx.c)(n); repeat (n+1) n' Œªx.c)‚ü©

[Repeat-True-v2]

    ‚ü®(s,œÉ), [x\n]c‚ü© ‚Üí (s', œÉ')  ‚ü®(s',œÉ'), repeat (n+1) n' Œªx.c‚ü© ‚Üí (s'', œÉ'')
    ------------------------------------------------------------  (where n < n')
    ‚ü®(s, œÉ), repeat n Œªx.c‚ü© ‚Üí (s'', œÉ'')

    The notation [x\n]c means:

      syntactically replace every instance of variable x with the numeral
      n in the expression c.
