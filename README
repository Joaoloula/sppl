Probabilistic Programming with Sum-Product Networks
===================================================

1. Installation

Please install Python 3 dependencies in requirements.txt.

2. Tests

Run the following command in the shell:

    $ ./check.sh

3. Specification

Domain Variables

  n โ Naturals
  r โ Reals
  w โ [0,1]
  s โ Strings
  x โ Vars

SPN Language

  ฮธ โ CDF
  d โ Dist :=
    Nominal {sแตข:pแตข โฃ i=1, โฆ, m} [Nominal]
    | Continuous ฮ              [RealContinuous]
    | Discrete ฮ                [RealDiscrete]

  s โ SPN :=
    (โ x d)                     [Leaf]
    | (โ sโ โฆ sโ)               [Product]
    | (โ (wโ sโ) โฆ (wโ sโ))     [Sum]

Query Language

  t โ Transforms :=
    id(x)                       [Identity]      // One-to-One
    | 1/t                       [Reciprocal]    // One-to-One
    | โฟโt                       [Radical]       // One-to-One
    | rแต                        [Exp]           // One-to-One
    | logแตฃ(t)                   [Log]           // One-to-One
    | abs(t)                    [Abs]           // Many-to-One
    | rโ + rโt + โฆ + rโtแต       [Poly]          // Many-to-One
    | ฯโtโ + ฯโtโ + ... + ฯโtโ  [Piecewise]     // Many-to-One

  v โ Outcomes :=
    (a, b)              [RealInterval]
    | {rโ, โฆ, rโ}       [RealFinite]
    | {sโ, โฆ, sโ}       [NominalFinite]

  ฯ โ Event :=
    | t in v            [Containment]
    | ฯโ and ฯโ         [Conjunction]
    | ฯโ or ฯโ          [Disjunction]
    | ~ฯ                [Negation]

  Remark: An Event ฯ is a Boolean-valued Transform t, thus
    [solve ฯ] := [invert ฯ {1}].

  invert              :: Transform -> โ(Reals) -> โ(Reals)
  solve               :: Event -> โ(Reals)
  logprob             :: SPN -> ฯ -> Reals
  condition           :: SPN -> ฯ -> SPN
  mutual-information  :: SPN -> ฯโ -> ฯโ -> Reals

Modeling Language

  c โ Command :=
    | x ~ d
    | x โ t
    | if ฯ then cโ else cโ
    | cโ ; cโ

Small Step Semantics

  The semantics of a program is a sum-product network.
  More specifically, the program state is a pair (s, ฯ) where
    ฯ โ Vars โ Transforms
    s โ SPN

    For any predicate ฯ โ Event and environment ฯ, define
    ฯ[ฯ] = case ฯ of
      t in v    | var(t) โ ฯ -> [ฯ[var(t)]] in v
                | otherwise -> ฯ
      ฯโ and ฯโ -> (ฯโ[ฯ] and ฯโ[ฯ])
      ฯโ or ฯโ -> (ฯโ[ฯ] or ฯโ[ฯ])
      ~ฯ -> ~ฯ[ฯ]

[Sample]  ----------------------------------
          โจ(s, ฯ), x ~ dโฉ โ (โ s (โ x d), ฯ)

[Assign]  -----------------------------
          โจ(s, ฯ), x โ tโฉ โ (s, [x\t]ฯ)

          โจ(s|ฯ[ฯ], ฯ), cโโฉ โ (sโ, ฯโ) โจ(s|~ฯ[ฯ], ฯ), cโโฉ โ (sโ, ฯโ)
[IfElse]  -----------------------------------------------------------
          โจ(s, ฯ), if ฯ then cโ else cโโฉ โ โ (๐[s, ฯ[ฯ]] (sโ, ฯโ))
                                             (1-๐[s, ฯ[ฯ]] (sโ, ฯโ))

             โจ(s, ฯ), cโ โ (sโ, ฯโ)  โจ(sโ, ฯโ), cโ โ (sโ, ฯโ)
[Sequence]   ------------------------------------------------
                      โจ(s, ฯ), cโ;cโโฉ โ (sโ, ฯโ)
